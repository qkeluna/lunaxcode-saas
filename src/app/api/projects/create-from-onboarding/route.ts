import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { getCloudflareContext } from '@/lib/db/context';
import { drizzle } from 'drizzle-orm/d1';
import { projects, projectAnswers, questions, serviceTypes, tasks, users } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { generatePRD, generateTasks } from '@/lib/ai/gemini';
import { notifyAdmin } from '@/lib/email/notifications';

export const runtime = 'edge';

export async function POST(request: NextRequest) {
  try {
    // 1. Check authentication
    const session = await auth();
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Get onboarding data from request
    const body = await request.json();
    const {
      serviceId,
      serviceName,
      description,
      questionAnswers,
      clientName,
      clientEmail,
      clientPhone
    } = body;

    // Validate required fields
    if (!serviceId || !description || !clientName || !clientEmail) {
      return NextResponse.json({
        error: 'Missing required fields',
        details: { serviceId, description, clientName, clientEmail }
      }, { status: 400 });
    }

    // 3. Get database connection
    const context = getCloudflareContext();
    if (!context) {
      return NextResponse.json({ error: 'Database context not available' }, { status: 503 });
    }

    const db = drizzle(context.env.DB);

    // 4. Get user ID from email (users table has id as primary key, not email)
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.email, session.user.email))
      .limit(1);

    if (!user) {
      return NextResponse.json({
        error: 'User not found. Please try logging in again.'
      }, { status: 404 });
    }

    // 5. Get service details
    const [service] = await db
      .select()
      .from(serviceTypes)
      .where(eq(serviceTypes.id, parseInt(serviceId)))
      .limit(1);

    if (!service) {
      return NextResponse.json({ error: 'Service not found' }, { status: 404 });
    }

    // 6. Parse timeline from service (e.g., "2-3 weeks" -> 21 days, "1-2 months" -> 45 days)
    let timelineDays = 30; // Default 30 days
    if (service.timeline) {
      const timelineStr = service.timeline.toLowerCase();
      if (timelineStr.includes('week')) {
        const weeks = parseInt(timelineStr.split('-')[1] || '2');
        timelineDays = weeks * 7;
      } else if (timelineStr.includes('month')) {
        const months = parseInt(timelineStr.split('-')[1] || '2');
        timelineDays = months * 30;
      }
    }

    // 7. Create project record
    const [project] = await db
      .insert(projects)
      .values({
        userId: user.id, // Use actual user ID from database
        serviceTypeId: service.id,
        name: `${serviceName} for ${clientName}`,
        service: serviceName,
        description: description,
        clientName: clientName,
        clientEmail: clientEmail,
        clientPhone: clientPhone || null,
        price: service.basePrice,
        timeline: timelineDays, // Use parsed timeline from service type
        budget: service.basePrice,
        prd: '', // Will be generated by AI (empty string to satisfy NOT NULL constraint)
        status: 'pending',
        paymentStatus: 'pending',
        depositAmount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    console.log('âœ… Project created:', project.id);

    // 7. Store question answers
    if (questionAnswers && typeof questionAnswers === 'object') {
      const answers = Object.entries(questionAnswers);

      for (const [questionKey, answerValue] of answers) {
        try {
          // Get question ID
          const [question] = await db
            .select()
            .from(questions)
            .where(eq(questions.questionKey, questionKey))
            .limit(1);

          if (question) {
            await db.insert(projectAnswers).values({
              projectId: project.id,
              questionId: question.id,
              questionKey: questionKey,
              answerValue: typeof answerValue === 'object'
                ? JSON.stringify(answerValue)
                : String(answerValue),
              createdAt: new Date(),
            });
          }
        } catch (error) {
          console.error(`Error storing answer for ${questionKey}:`, error);
          // Continue with other answers even if one fails
        }
      }

      console.log(`âœ… ${answers.length} question answers stored`);
    }

    // 8. Generate PRD with AI
    console.log('ðŸ¤– Generating PRD with AI...');
    const geminiApiKey = process.env.GEMINI_API_KEY;

    if (!geminiApiKey) {
      console.error('âŒ GEMINI_API_KEY not configured');
      return NextResponse.json(
        { error: 'AI service not configured. Please contact support.' },
        { status: 500 }
      );
    }

    let generatedPRD: string;
    try {
      generatedPRD = await generatePRD({
        serviceName: serviceName,
        description: description,
        questionAnswers: questionAnswers || {},
        apiKey: geminiApiKey
      });
      console.log('âœ… PRD generated successfully');
    } catch (error: any) {
      console.error('âŒ Error generating PRD:', error);
      // Fallback to a basic PRD if AI generation fails
      generatedPRD = `# Project Requirements Document

## Project Overview

**Project Name**: ${serviceName} for ${clientName}

**Service Type**: ${serviceName}

**Description**: ${description}

## Client Requirements

${Object.entries(questionAnswers || {})
  .map(([key, value]) => {
    const formattedValue = Array.isArray(value) ? value.join(', ') : value;
    return `- ${key.replace(/_/g, ' ')}: ${formattedValue}`;
  })
  .join('\n')}

## Next Steps

Our team will review your requirements and reach out with a detailed project plan.`;
    }

    // 9. Generate tasks with AI
    console.log('ðŸ¤– Generating tasks with AI...');
    let generatedTasks: Array<{
      title: string;
      description: string;
      section: string;
      priority: string;
      estimatedHours: number;
      dependencies: string;
      order: number;
    }> = [];

    try {
      generatedTasks = await generateTasks({
        prd: generatedPRD,
        apiKey: geminiApiKey
      });
      console.log(`âœ… ${generatedTasks.length} tasks generated successfully`);
    } catch (error: any) {
      console.error('âŒ Error generating tasks:', error);
      // Continue without tasks - can be generated later by admin
    }

    // 10. Update project with generated PRD
    await db
      .update(projects)
      .set({
        prd: generatedPRD,
        updatedAt: new Date()
      })
      .where(eq(projects.id, project.id));

    console.log('âœ… PRD saved to database');

    // 11. Store generated tasks
    if (generatedTasks.length > 0) {
      for (const task of generatedTasks) {
        try {
          await db.insert(tasks).values({
            projectId: project.id,
            title: task.title,
            description: task.description,
            section: task.section,
            priority: task.priority as 'low' | 'medium' | 'high',
            estimatedHours: task.estimatedHours,
            dependencies: task.dependencies,
            order: task.order,
            status: 'pending',
            createdAt: new Date(),
            updatedAt: new Date()
          });
        } catch (error) {
          console.error(`Error storing task ${task.title}:`, error);
          // Continue with other tasks
        }
      }
      console.log(`âœ… ${generatedTasks.length} tasks saved to database`);
    }

    // 12. Send admin alert for new project
    try {
      notifyAdmin(db, {
        type: 'new_project',
        clientName: clientName,
        clientEmail: clientEmail,
        projectTitle: `${serviceName} for ${clientName}`,
        projectId: project.id.toString(),
        details: `Service: ${serviceName}\nBudget: â‚±${service.basePrice.toLocaleString()}\nTimeline: ${service.timeline || `${timelineDays} days`}`,
      }).catch(err => {
        console.error('Failed to send admin new project alert:', err);
      });
    } catch (notificationError) {
      console.error('Error sending project notification:', notificationError);
    }

    // 13. Return success
    return NextResponse.json({
      success: true,
      projectId: project.id,
      message: 'Project created successfully with AI-generated PRD and tasks.',
      redirectUrl: `/projects/${project.id}`,
      prdGenerated: true,
      tasksGenerated: generatedTasks.length
    });

  } catch (error: any) {
    console.error('Error creating project:', error);
    return NextResponse.json(
      {
        error: error.message || 'Failed to create project',
        details: error.stack
      },
      { status: 500 }
    );
  }
}
