import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { getCloudflareContext } from '@/lib/db/context';
import { drizzle } from 'drizzle-orm/d1';
import { projects, projectAnswers, questions, serviceTypes, tasks } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { generatePRD, generateTasks } from '@/lib/ai/gemini';

export const runtime = 'edge';

export async function POST(request: NextRequest) {
  try {
    // 1. Check authentication
    const session = await auth();
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Get onboarding data from request
    const body = await request.json();
    const {
      serviceId,
      serviceName,
      description,
      questionAnswers,
      clientName,
      clientEmail,
      clientPhone
    } = body;

    // Validate required fields
    if (!serviceId || !description || !clientName || !clientEmail) {
      return NextResponse.json({
        error: 'Missing required fields',
        details: { serviceId, description, clientName, clientEmail }
      }, { status: 400 });
    }

    // 3. Get database connection
    const context = getCloudflareContext();
    if (!context) {
      return NextResponse.json({ error: 'Database context not available' }, { status: 503 });
    }

    const db = drizzle(context.env.DB);

    // 4. Get service details
    const [service] = await db
      .select()
      .from(serviceTypes)
      .where(eq(serviceTypes.id, parseInt(serviceId)))
      .limit(1);

    if (!service) {
      return NextResponse.json({ error: 'Service not found' }, { status: 404 });
    }

    // 5. Create project record
    const [project] = await db
      .insert(projects)
      .values({
        userId: session.user.email, // Using email as userId since that's what NextAuth provides
        serviceTypeId: service.id,
        name: `${serviceName} for ${clientName}`,
        service: serviceName,
        description: description,
        clientName: clientName,
        clientEmail: clientEmail,
        clientPhone: clientPhone || null,
        price: service.basePrice,
        timeline: null, // Will be set by AI or from service
        budget: service.basePrice,
        prd: null, // Will be generated by AI
        status: 'pending',
        paymentStatus: 'pending',
        depositAmount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    console.log('‚úÖ Project created:', project.id);

    // 6. Store question answers
    if (questionAnswers && typeof questionAnswers === 'object') {
      const answers = Object.entries(questionAnswers);

      for (const [questionKey, answerValue] of answers) {
        try {
          // Get question ID
          const [question] = await db
            .select()
            .from(questions)
            .where(eq(questions.questionKey, questionKey))
            .limit(1);

          if (question) {
            await db.insert(projectAnswers).values({
              projectId: project.id,
              questionId: question.id,
              questionKey: questionKey,
              answerValue: typeof answerValue === 'object'
                ? JSON.stringify(answerValue)
                : String(answerValue),
              createdAt: new Date(),
            });
          }
        } catch (error) {
          console.error(`Error storing answer for ${questionKey}:`, error);
          // Continue with other answers even if one fails
        }
      }

      console.log(`‚úÖ ${answers.length} question answers stored`);
    }

    // 7. Generate PRD and tasks asynchronously (don't wait)
    // This runs in the background and updates the project when complete
    generatePRDAndTasks(project.id, service, serviceName, description, questionAnswers, context.env.DB)
      .catch(error => {
        console.error(`‚ùå Failed to generate PRD/tasks for project ${project.id}:`, error);
      });

    console.log('ü§ñ AI generation started in background');

    // 8. Return success immediately (PRD generation happens in background)
    return NextResponse.json({
      success: true,
      projectId: project.id,
      message: 'Project created successfully. PRD and tasks are being generated...',
      redirectUrl: `/projects/${project.id}`
    });

  } catch (error: any) {
    console.error('Error creating project:', error);
    return NextResponse.json(
      {
        error: error.message || 'Failed to create project',
        details: error.stack
      },
      { status: 500 }
    );
  }
}

// Async function to generate PRD and tasks (runs in background)
async function generatePRDAndTasks(
  projectId: number,
  service: any,
  serviceName: string,
  description: string,
  questionAnswers: any,
  dbBinding: any
) {
  try {
    const db = drizzle(dbBinding);

    console.log(`ü§ñ Generating PRD for project ${projectId}...`);

    // Generate PRD
    const prd = await generatePRD({
      serviceName: serviceName,
      description,
      questionAnswers: questionAnswers || {}
    });

    console.log(`‚úÖ PRD generated (${prd.length} characters)`);

    // Update project with PRD
    await db
      .update(projects)
      .set({ prd, updatedAt: new Date() })
      .where(eq(projects.id, projectId));

    console.log('‚úÖ PRD saved to database');

    console.log(`ü§ñ Generating tasks for project ${projectId}...`);

    // Generate tasks
    const generatedTasks = await generateTasks({ prd });

    console.log(`‚úÖ ${generatedTasks.length} tasks generated`);

    // Insert tasks
    for (const task of generatedTasks) {
      await db.insert(tasks).values({
        projectId: projectId,
        title: task.title,
        description: task.description,
        section: task.section,
        priority: task.priority,
        status: 'pending',
        estimatedHours: task.estimatedHours,
        dependencies: task.dependencies,
        order: task.order,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }

    console.log(`‚úÖ All tasks saved to database for project ${projectId}`);

  } catch (error) {
    console.error(`‚ùå Failed to generate PRD/tasks for project ${projectId}:`, error);
    // Don't throw - just log the error so the project is still created
  }
}
