import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { getCloudflareContext } from '@/lib/db/context';
import { drizzle } from 'drizzle-orm/d1';
import { projects, projectAnswers, questions, serviceTypes, tasks, users } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { generatePRD, generateTasks } from '@/lib/ai/gemini';

export const runtime = 'edge';

export async function POST(request: NextRequest) {
  try {
    // 1. Check authentication
    const session = await auth();
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Get onboarding data from request
    const body = await request.json();
    const {
      serviceId,
      serviceName,
      description,
      questionAnswers,
      clientName,
      clientEmail,
      clientPhone
    } = body;

    // Validate required fields
    if (!serviceId || !description || !clientName || !clientEmail) {
      return NextResponse.json({
        error: 'Missing required fields',
        details: { serviceId, description, clientName, clientEmail }
      }, { status: 400 });
    }

    // 3. Get database connection
    const context = getCloudflareContext();
    if (!context) {
      return NextResponse.json({ error: 'Database context not available' }, { status: 503 });
    }

    const db = drizzle(context.env.DB);

    // 4. Get user ID from email (users table has id as primary key, not email)
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.email, session.user.email))
      .limit(1);

    if (!user) {
      return NextResponse.json({
        error: 'User not found. Please try logging in again.'
      }, { status: 404 });
    }

    // 5. Get service details
    const [service] = await db
      .select()
      .from(serviceTypes)
      .where(eq(serviceTypes.id, parseInt(serviceId)))
      .limit(1);

    if (!service) {
      return NextResponse.json({ error: 'Service not found' }, { status: 404 });
    }

    // 6. Create project record
    const [project] = await db
      .insert(projects)
      .values({
        userId: user.id, // Use actual user ID from database
        serviceTypeId: service.id,
        name: `${serviceName} for ${clientName}`,
        service: serviceName,
        description: description,
        clientName: clientName,
        clientEmail: clientEmail,
        clientPhone: clientPhone || null,
        price: service.basePrice,
        timeline: 0, // Will be calculated from service timeline or AI (0 = pending calculation)
        budget: service.basePrice,
        prd: '', // Will be generated by AI (empty string to satisfy NOT NULL constraint)
        status: 'pending',
        paymentStatus: 'pending',
        depositAmount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    console.log('‚úÖ Project created:', project.id);

    // 7. Store question answers
    if (questionAnswers && typeof questionAnswers === 'object') {
      const answers = Object.entries(questionAnswers);

      for (const [questionKey, answerValue] of answers) {
        try {
          // Get question ID
          const [question] = await db
            .select()
            .from(questions)
            .where(eq(questions.questionKey, questionKey))
            .limit(1);

          if (question) {
            await db.insert(projectAnswers).values({
              projectId: project.id,
              questionId: question.id,
              questionKey: questionKey,
              answerValue: typeof answerValue === 'object'
                ? JSON.stringify(answerValue)
                : String(answerValue),
              createdAt: new Date(),
            });
          }
        } catch (error) {
          console.error(`Error storing answer for ${questionKey}:`, error);
          // Continue with other answers even if one fails
        }
      }

      console.log(`‚úÖ ${answers.length} question answers stored`);
    }

    // 8. Check if Gemini API key is available
    const geminiApiKey = context.env.GEMINI_API_KEY || process.env.GEMINI_API_KEY;
    
    if (!geminiApiKey) {
      console.warn('‚ö†Ô∏è GEMINI_API_KEY not found. PRD will not be generated.');
      // Update project with a placeholder PRD
      await db
        .update(projects)
        .set({
          prd: `# Project Requirements Document\n\n**Project**: ${serviceName} for ${clientName}\n\n**Description**: ${description}\n\n‚ö†Ô∏è AI-generated PRD is not available. Please configure GEMINI_API_KEY in Cloudflare secrets.\n\nTo generate PRD:\n1. Set GEMINI_API_KEY secret in Cloudflare\n2. Edit this project to regenerate`,
          updatedAt: new Date()
        })
        .where(eq(projects.id, project.id));
    } else {
      // Generate PRD and tasks asynchronously (don't wait)
      // This runs in the background and updates the project when complete
      generatePRDAndTasks(
        project.id,
        service,
        serviceName,
        description,
        questionAnswers,
        context.env.DB,
        geminiApiKey
      )
        .catch(error => {
          console.error(`‚ùå Failed to generate PRD/tasks for project ${project.id}:`, error);
        });

      console.log('ü§ñ AI generation started in background');
    }

    // 9. Return success immediately (PRD generation happens in background)
    return NextResponse.json({
      success: true,
      projectId: project.id,
      message: 'Project created successfully. PRD and tasks are being generated...',
      redirectUrl: `/projects/${project.id}`
    });

  } catch (error: any) {
    console.error('Error creating project:', error);
    return NextResponse.json(
      {
        error: error.message || 'Failed to create project',
        details: error.stack
      },
      { status: 500 }
    );
  }
}

// Async function to generate PRD and tasks (runs in background)
async function generatePRDAndTasks(
  projectId: number,
  service: any,
  serviceName: string,
  description: string,
  questionAnswers: any,
  dbBinding: any,
  geminiApiKey: string
) {
  try {
    const db = drizzle(dbBinding);

    console.log(`ü§ñ Generating PRD for project ${projectId}...`);
    console.log(`üîë API Key available: ${!!geminiApiKey}`);

    // Generate PRD
    const prd = await generatePRD({
      serviceName: serviceName,
      description,
      questionAnswers: questionAnswers || {},
      apiKey: geminiApiKey
    });

    console.log(`‚úÖ PRD generated (${prd.length} characters)`);

    // Update project with PRD
    await db
      .update(projects)
      .set({ prd, updatedAt: new Date() })
      .where(eq(projects.id, projectId));

    console.log('‚úÖ PRD saved to database');

    console.log(`ü§ñ Generating tasks for project ${projectId}...`);

    // Generate tasks
    const generatedTasks = await generateTasks({
      prd,
      apiKey: geminiApiKey
    });

    console.log(`‚úÖ ${generatedTasks.length} tasks generated`);

    // Insert tasks
    for (const task of generatedTasks) {
      await db.insert(tasks).values({
        projectId: projectId,
        title: task.title,
        description: task.description,
        section: task.section,
        priority: task.priority,
        status: 'pending',
        estimatedHours: task.estimatedHours,
        dependencies: task.dependencies,
        order: task.order,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }

    console.log(`‚úÖ All tasks saved to database for project ${projectId}`);

  } catch (error: any) {
    console.error(`‚ùå Failed to generate PRD/tasks for project ${projectId}:`, error);
    
    // Save error message as PRD so user knows what happened
    try {
      await db
        .update(projects)
        .set({
          prd: `# Project Requirements Document\n\n**Error Generating PRD**\n\n‚ö†Ô∏è An error occurred while generating the AI-powered PRD.\n\n**Error**: ${error.message || 'Unknown error'}\n\n**What to do:**\n1. Check that GEMINI_API_KEY is properly configured\n2. Verify your Gemini API quota\n3. Try creating a new project\n\n**Project Details:**\n- Service: ${serviceName}\n- Description: ${description}\n\nPlease contact support if this issue persists.`,
          updatedAt: new Date()
        })
        .where(eq(projects.id, projectId));
    } catch (updateError) {
      console.error('Failed to update project with error message:', updateError);
    }
  }
}
