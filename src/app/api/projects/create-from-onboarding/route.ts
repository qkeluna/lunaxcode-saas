import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { getCloudflareContext } from '@/lib/db/context';
import { drizzle } from 'drizzle-orm/d1';
import { projects, projectAnswers, questions, serviceTypes, tasks, users } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { generatePRD, generateTasks } from '@/lib/ai/gemini';

export const runtime = 'edge';

export async function POST(request: NextRequest) {
  try {
    // 1. Check authentication
    const session = await auth();
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Get onboarding data from request
    const body = await request.json();
    const {
      serviceId,
      serviceName,
      description,
      questionAnswers,
      clientName,
      clientEmail,
      clientPhone
    } = body;

    // Validate required fields
    if (!serviceId || !description || !clientName || !clientEmail) {
      return NextResponse.json({
        error: 'Missing required fields',
        details: { serviceId, description, clientName, clientEmail }
      }, { status: 400 });
    }

    // 3. Get database connection
    const context = getCloudflareContext();
    if (!context) {
      return NextResponse.json({ error: 'Database context not available' }, { status: 503 });
    }

    const db = drizzle(context.env.DB);

    // 4. Get user ID from email (users table has id as primary key, not email)
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.email, session.user.email))
      .limit(1);

    if (!user) {
      return NextResponse.json({
        error: 'User not found. Please try logging in again.'
      }, { status: 404 });
    }

    // 5. Get service details
    const [service] = await db
      .select()
      .from(serviceTypes)
      .where(eq(serviceTypes.id, parseInt(serviceId)))
      .limit(1);

    if (!service) {
      return NextResponse.json({ error: 'Service not found' }, { status: 404 });
    }

    // 6. Create project record
    const [project] = await db
      .insert(projects)
      .values({
        userId: user.id, // Use actual user ID from database
        serviceTypeId: service.id,
        name: `${serviceName} for ${clientName}`,
        service: serviceName,
        description: description,
        clientName: clientName,
        clientEmail: clientEmail,
        clientPhone: clientPhone || null,
        price: service.basePrice,
        timeline: 0, // Will be calculated from service timeline or AI (0 = pending calculation)
        budget: service.basePrice,
        prd: '', // Will be generated by AI (empty string to satisfy NOT NULL constraint)
        status: 'pending',
        paymentStatus: 'pending',
        depositAmount: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    console.log('‚úÖ Project created:', project.id);

    // 7. Store question answers
    if (questionAnswers && typeof questionAnswers === 'object') {
      const answers = Object.entries(questionAnswers);

      for (const [questionKey, answerValue] of answers) {
        try {
          // Get question ID
          const [question] = await db
            .select()
            .from(questions)
            .where(eq(questions.questionKey, questionKey))
            .limit(1);

          if (question) {
            await db.insert(projectAnswers).values({
              projectId: project.id,
              questionId: question.id,
              questionKey: questionKey,
              answerValue: typeof answerValue === 'object'
                ? JSON.stringify(answerValue)
                : String(answerValue),
              createdAt: new Date(),
            });
          }
        } catch (error) {
          console.error(`Error storing answer for ${questionKey}:`, error);
          // Continue with other answers even if one fails
        }
      }

      console.log(`‚úÖ ${answers.length} question answers stored`);
    }

    // 8. Check if Gemini API key is available
    const geminiApiKey = context.env.GEMINI_API_KEY || process.env.GEMINI_API_KEY;
    
    if (!geminiApiKey) {
      console.error('‚ö†Ô∏è GEMINI_API_KEY not found. PRD will not be generated.');
      console.error('Please set GEMINI_API_KEY in Cloudflare secrets for AI generation.');
      // Update project with a professional client-facing PRD
      await db
        .update(projects)
        .set({
          prd: `# Project Requirements Document

## Project Overview

**Project Name**: ${serviceName} for ${clientName}

**Service Type**: ${serviceName}

**Description**: ${description}

---

## Project Details

Your project has been successfully created and our team will review it shortly. We'll be creating a comprehensive Project Requirements Document (PRD) that includes:

- **Executive Summary** - Overview of project goals and objectives
- **Technical Specifications** - Detailed technical requirements and architecture
- **Feature Breakdown** - Complete list of features and functionality
- **Design Guidelines** - UI/UX specifications and branding
- **Timeline & Milestones** - Project phases and delivery schedule
- **Success Metrics** - How we'll measure project success

## Next Steps

1. **Initial Review** - Our team will review your requirements (24-48 hours)
2. **PRD Creation** - We'll create a detailed requirements document
3. **Client Approval** - You'll review and approve the PRD
4. **Payment** - 50% deposit to begin development
5. **Project Kickoff** - Development begins once deposit is verified

## Questions?

If you have any questions or need to update your requirements, please contact our team.

---

*This document will be updated with detailed specifications by our team.*`,
          updatedAt: new Date()
        })
        .where(eq(projects.id, project.id));
    } else {
      // Generate PRD and tasks asynchronously (don't wait)
      // This runs in the background and updates the project when complete
      generatePRDAndTasks(
        project.id,
        service,
        serviceName,
        description,
        questionAnswers,
        context.env.DB,
        geminiApiKey
      )
        .catch(error => {
          console.error(`‚ùå Failed to generate PRD/tasks for project ${project.id}:`, error);
        });

      console.log('ü§ñ AI generation started in background');
    }

    // 9. Return success immediately (PRD generation happens in background)
    return NextResponse.json({
      success: true,
      projectId: project.id,
      message: 'Project created successfully. PRD and tasks are being generated...',
      redirectUrl: `/projects/${project.id}`
    });

  } catch (error: any) {
    console.error('Error creating project:', error);
    return NextResponse.json(
      {
        error: error.message || 'Failed to create project',
        details: error.stack
      },
      { status: 500 }
    );
  }
}

// Async function to generate PRD and tasks (runs in background)
async function generatePRDAndTasks(
  projectId: number,
  service: any,
  serviceName: string,
  description: string,
  questionAnswers: any,
  dbBinding: any,
  geminiApiKey: string
) {
  try {
    const db = drizzle(dbBinding);

    console.log(`ü§ñ Generating PRD for project ${projectId}...`);
    console.log(`üîë API Key available: ${!!geminiApiKey}`);

    // Generate PRD
    const prd = await generatePRD({
      serviceName: serviceName,
      description,
      questionAnswers: questionAnswers || {},
      apiKey: geminiApiKey
    });

    console.log(`‚úÖ PRD generated (${prd.length} characters)`);

    // Update project with PRD
    await db
      .update(projects)
      .set({ prd, updatedAt: new Date() })
      .where(eq(projects.id, projectId));

    console.log('‚úÖ PRD saved to database');

    console.log(`ü§ñ Generating tasks for project ${projectId}...`);

    // Generate tasks
    const generatedTasks = await generateTasks({
      prd,
      apiKey: geminiApiKey
    });

    console.log(`‚úÖ ${generatedTasks.length} tasks generated`);

    // Insert tasks
    for (const task of generatedTasks) {
      await db.insert(tasks).values({
        projectId: projectId,
        title: task.title,
        description: task.description,
        section: task.section,
        priority: task.priority,
        status: 'pending',
        estimatedHours: task.estimatedHours,
        dependencies: task.dependencies,
        order: task.order,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
    }

    console.log(`‚úÖ All tasks saved to database for project ${projectId}`);

  } catch (error: any) {
    console.error(`‚ùå Failed to generate PRD/tasks for project ${projectId}:`, error);
    console.error('Error details:', error.message);
    
    // Save professional client-facing message (hide technical errors)
    try {
      await db
        .update(projects)
        .set({
          prd: `# Project Requirements Document

## Project Overview

**Project Name**: ${serviceName}

**Description**: ${description}

---

## Status Update

Your project has been successfully created! Our team will be reviewing your requirements and creating a detailed Project Requirements Document.

## What Happens Next?

1. **Team Review** - Our experts will analyze your project requirements
2. **PRD Creation** - We'll create a comprehensive requirements document manually
3. **Timeline Planning** - We'll establish milestones and deliverables
4. **Your Review** - You'll have a chance to review and provide feedback
5. **Project Kickoff** - Once approved, we'll begin development

## Expected Timeline

- **PRD Completion**: 24-48 hours
- **Your Review**: 2-3 business days
- **Project Start**: After 50% deposit payment is verified

## Need Changes?

If you need to update your project requirements or have questions, please contact our team anytime.

---

*Our team will reach out to you shortly with the complete Project Requirements Document.*`,
          updatedAt: new Date()
        })
        .where(eq(projects.id, projectId));
    } catch (updateError) {
      console.error('Failed to update project with fallback PRD:', updateError);
    }
  }
}
